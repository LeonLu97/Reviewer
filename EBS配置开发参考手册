	

	
EBS配置开发参考手册	




文档版本:01
发布日期:2017-12-01


	版权所有©版权所有权人

 
	

	注意	
	由于产品版本升级或其他原因，本文档内容会不定期进行更新。除非另有约定，本文档仅作为使用指导，本文档中的所有陈述、信息和建议不构成任何明示或暗示的担保。	
 
目  录
1 变更说明	1-1
2 配置开发概述	2-1
3 基本配置开发（邵珠成）	3-1
3.1 配置页面开发（左星星）	3-1
3.1.1 新页面的开发	3-1
3.1.1.1 ××_list.ftl编写	3-1
3.1.1.2 ××_input.ftl编写	3-3
3.1.2 修改原有页面	3-4
3.2 配置对象开发（邓雪磊）	3-5
3.2.1 新增配置对象类	3-5
3.2.1.3 新增对象	3-5
3.2.1.4 新增action类	3-5
3.2.1.5 添加新增url的权限	3-6
3.2.2 修改配置文件	3-6
3.2.2.6 修改表结构文件	3-6
3.2.2.7 修改hibernate映射文件，建立对象与表关联	3-6
3.2.3 数据保存的前（后）处理	3-7
3.2.3.8 数据保存前处理	3-7
3.2.3.9 数据保存后处理	3-7
3.2.4 数据校验说明	3-8
3.2.4.10 校验文件配置	3-8
3.2.4.11 错误码定义	3-8
3.2.4.12 界面显示信息和action中抛出的提示信息（i18n）	3-9
3.3 配置数据导出（郭鹏）	3-9
3.3.1 前后台交互	3-9
3.3.2 后台数据处理	3-10
3.3.3 导出文件配置：	3-10
3.4 配置模板开发（郭鹏）	3-12
3.4.1 保存处理流程	3-12
3.4.1.13 IMSI保存	3-12
3.4.1.14 终端用户保存	3-12
3.4.1.15 固定用户保存	3-12
3.4.1.16 IMEI保存	3-13
3.4.2 修改处理流程	3-13
3.4.2.17 IMSI修改	3-13
3.4.2.18 终端用户修改	3-13
3.4.2.19 IMEI修改	3-14
3.4.2.20 终端用户修改	3-14
3.4.3 模板在开户中的使用	3-14
3.5 批量导入开发（严朝祥）	3-15
3.5.1 相关功能配置	3-15
3.5.1.21 开发工具配置	3-15
3.5.1.22 ClientRule页配置	3-15
3.5.1.23 ServerRule 页配置	3-16
3.5.1.24 ValidationConfig 配置	3-17
3.6 常见问题和解答（邵珠成）	3-18
4 MDC同步开发（赵宇）	4-18
4.1 增量同步开发（郭鹏）	4-18
4.1.1 新增字段同步	4-18
4.1.2 新增对象同步	4-19
4.2 全同步开发（赵宇）	4-20
4.2.1 全同步概述	4-20
4.2.2 全同步流程	4-20
4.3 常见问题和解答（赵宇）	4-22
4.3.1 我第一次定位MDC全同步,增量同步的问题,只有这份文档和代码，能问的人很少，怎么办?	4-22
4.3.2 什么样的MDC是正常，正常的MDC操作是怎样的？	4-22
4.3.3 添加MDC/MRS设备添加不上怎么办?	4-22
4.3.4 MDC阻塞/不同步了怎么定位?	4-23
4.3.5 升级和切换应用模式引起的MDC同步异常	4-24
4.3.6 任何时候都不要忘记看日志和代码来定位问题！	4-24
5 核心网同步开发（赵宇）	5-25
5.1 增量同步开发（邓雪磊）	5-25
5.1.1 增量同步涉及文件	5-25
5.1.2 增量同步流程	5-25
5.2 全同步开发（邓雪磊）	5-26
5.2.1 全同步涉及文件	5-26
5.2.2 生成全同步文件	5-27
5.3 核心网增量同步和全同步命令实例	5-28
5.3.1 增量同步实例	5-28
5.3.2 全同步实例	5-30
5.4 常见问题和解答（赵宇）	5-40
5.4.1 我第一次开发核心网的功能，有什么办法:找以前前面的同事做过的功能，找到提交记录，然后合入测试并在过程中读懂每一个文件的作用。	5-40
5.4.2 关于核心网设备是否正常，添加核心网添加不上，核心网阻塞/不同步的问题定位。	5-41
5.4.3 核心网特别问题1:中英文匹配引起的全同步/连接失败	5-41
5.4.4 核心网特别问题2：2U核心网无论怎样都不能全同步成功。	5-42
5.4.5 核心网特别问题3:  UDC无法创建和核心网的连接，总是被拒绝。	5-42
5.4.6 核心网POOL关系的含义	5-42
5.4.7 最终的解决办法：还是那句，老老实实看代码,看日志来定位问题。	5-42
6 UDC同步开发（蔡茂）	6-43
6.1 增量同步开发（蔡茂）	6-43
6.1.1 相关XML配置	6-43
6.1.1.1 dispatch_ne.xml配置	6-43
6.1.1.2 udc_sync.xml配置	6-44
6.1.2 数据筛选处理	6-45
6.1.3 对象依赖处理	6-47
6.2 全同步开发（蔡茂）	6-50
6.2.1 相关XML配置	6-50
6.2.2 数据导出特殊处理	6-51
6.3 常见问题和解答（蔡茂）	6-52
6.3.1 UDC间同步需要修改那些文件？	6-52
6.3.2 如何判断数据筛选的原则？	6-52
7 第三方接口开发（邵珠成）	7-53
7.1 NBI接口开发（尹良运）	7-53
7.1.1 NBI接口简介	7-53
7.1.2 新增接口编写思路	7-56
7.1.3 新增接口代码示例	7-56
7.1.4 新增接口测试方法	7-66
7.2 UDI接口开发（赵宇）	7-74
7.2.1 DC创建动态组入口	7-74
7.2.2 终端UE创建动态组入口	7-75
7.2.3 动态组,临时组,派接组 组号分配逻辑	7-75
7.2.4 如何增加一个UDI接口	7-76
7.3 常见问题和解答（邵珠成）	7-76
 
1 变更说明
这里描述了各个版本间的变更信息。
01 (2017-12-01)
第一次正式发布。
 
2 配置开发概述
描述在EBS配置开发各项功能中常见修改点以及注意事项。
 
3 基本配置开发（邵珠成）
3.1 配置页面开发（左星星）
目前UDC显示页面都是使用ftl格式的文件来编写的，头部引用的资源大部分写在header.ftl里（有些旧的页面没有修改，会引入一堆资源，当然一些特别需要使用的资源需要自己引用）。目前页面的开发可以分为两种，新页面和修改原有页面。
3.1.1 新页面的开发
一般开发步骤如下：
1.	与后台确定接口
确定页面的名称，功能的方法名，字段名称，i18n。
2.	开发列表页面
页面显示的操作一般有编辑、删除、新增、批量、导出等。
3.	开发编辑页面
编辑一般包括添加、修改。
3.1.1.1 ××_list.ftl编写
××_list.ftl页面是通过列表的方式向用户展示模块下的基本信息，以呼叫转移列表页面为例：
 
 
				 
1、	在<head></head>中引入所需资源，在<script></script>中写js方法。
2、	列头筛选有固定的格式，注意字段类型，列号。showSearchFilter(tdId,type,tdNum,serNm,value,valType,serWay,flg,nodes,values)是本系统筛选使用的方法。其中tdId ：检索的列，type：检索类型，tdNum：检索列号，serNm：检索名称，value：检索值，valType：检索值类型，flg：1画面事件 2后台事件，nodes、 values：隐式传递参数。这个方法在admin.js里面。  
3、	显示值时注意<#noescape></#noescape>标签的使用。
4、	因添加、修改、删除、批量删除等方法大多使用通用的方面（一般用class标记），故使用时对嵌套格式有严格的要求，一定要按照约定的格式来写。
3.1.1.2 ××_input.ftl编写 
一般简单的页面将查看、添加和修改页面写在同一个ftl文件中，但有些页面比较复杂，会分开写，如卡、终端之类的。用户与模板因为历史原因，写得比较混乱，固定用户的新增和修改都写在一个页面：ebs_user_manage_openuser.ftl，终端用户的新建与编辑写在两个页面。
 
 
 
1、	编辑页面的js主要的功能就是对数据的校验、ajax提交表单（POST）和各种操作所触发事件的处理。
2、	HTML中使用form来写，编写的时候注意排版、样式之类的，但是都可以根据需求来灵活变动的。
3、	与列表相同，显示值时注意<#noescape></#noescape>标签的使用。
3.1.2 修改原有页面
在已有的页面上进行修改相对于做全新的页面来说比较简单。基本步骤如下：
1、	找到要修改的页面。
在具体的页面上右键 -> 属性，我们会看到弹出如下页面：
 
		在圈出来的红色区域：“ebs_call_forward!list.action”，我们截出“!”前面的字符，去掉下划线，加上“action”，即可以找到页面调用的action名称，本例子的action名称是“ebscallforwardaction”（不区分大小写），在代码中找到这个action，“!”后面“action”前面的是页面调出的方法的名称，找到这个方法，看返回值，本例子的方法是“list”，返回值是“list”，通过返回值字符找到页面，若找不到则加上“!”前面的字符+下划线+返回值，则可以找到具体的ftl。本例子的ftl就是“ebs_call_forward_list.ftl”。
  
2、	与SE及后台开发人员确定好元素添加的具体位置，即可编写代码。
3、	要注意前后台字段保持一致，出现问题打日志排查问题。
4、	新增或者修改都需与原有页面风格保持一致，不要出现不和谐的元素。
5、	修改原有页面注意一定要把所有需要改变的地方都找到，不要有遗漏。比如说一般在用户里面增加一种能力，就要考虑公专网都要修改，涉及的页面有用户的新增、修改、批量修改、模板的新增和修改。
3.2 配置对象开发（邓雪磊）
3.2.1 新增配置对象类
3.2.1.3  新增对象
基本说明：新增一项配置，涉及增删查改的操作对象，贯穿所有主流程使用
	继承EBSDomainObject
	参数生成get、set方法
	序列化serialVersionUID
	生成toString方法
	例如UDCGroupCategory.Java
3.2.1.4  新增action类
基本说明：action中，包括增删查改以及必要的url跳转方法
	继承BaseAdminAction
	序列化serialVersionUID
	添加必要的前台交互参数，udcGroupCategory
	交互参数需生成get、set方法
3.2.1.5 添加新增url的权限
文件：	java\udc_main\omc-web-ebsclient\src\main\conf\applicationContext-security.xml
	java\udc_main\omc-web-ebsclient\src\main\conf\udcsecurity\UdcSecurityMeta.xml
例如： <intercept-url pattern= "/frame/ebs_group_category!list.action" access="OPM_ALL_QUERY"/>
<UdcSecurityItem urlPattern= "/frame/ebs_group_category!list.action"
access="OPM_ALL_QUERY" licItem="" isCheckToken="1" />
3.2.2 修改配置文件
3.2.2.6 修改表结构文件
修改sql文件，必须同步修改升级规则；新增字段，需要检查修改初始化sql脚本。
涉及文件：
java\udc_main\omc-server-buz\omc-opm-server\src\main\ddl\create-tables.sql  
java\udc_main\omc-server-buz\omc-opm-server\src\main\ddl\init_en.sql 
java\udc_main\omc-server-buz\omc-opm-server\src\main\ddl\init_zh.sql
java\udc_main\omc-platform\omc-platform-server\src\main\ddl\create-tables-common.sql
java\udc_main\omc-platform\omc-platform-server\src\main\ddl\ebs\init_en.sql
java\udc_main\omc-platform\omc-platform-server\src\main\ddl\ebs\init_zh.sqlcode\install\scripts\udc_install\InitUdcDbData.sh---根据安装模式或不同情况,初始化数据
3.2.2.7 修改hibernate映射文件，建立对象与表关联
文件：java\udc_main\omc-server-buz\omc-opm-server\src\main\resources\com\shjv\tdscdma\omc\server\opm\dao\impl\mappings\opm.hbm.xml
	<!-- UDC 组群-群组信息 -->
  	<class name="com.shjv.tdscdma.ebs.bean.udc.UDCGroupCategoryGroup"
         table="opm_groupcategory_group"
         lazy="false"
         dynamic-insert="true"
         dynamic-update="true">
    		<id name="id" type="long">
      		<column name="id" />
      		<generator class="native" />
    		</id>
    		<property name="groupNumber"
              column="GROUPNUMBER"
              type="string" />
    		<property name="categoryNumber"
              column="CategoryNumber"
              type="long" />
	</class>
3.2.3 数据保存的前（后）处理
3.2.3.8  数据保存前处理
基本说明：针对增改删操作，配置相应的处理类，处理类中对数据对象做具体处理
文件：java\udc_main\omc-server-buz\omc-opm-server\src\main\conf\beforetreatment.xml
<UDCOBJ obj="GROUPCATEGORY">
      <ADD>
      	<FILTER desc="GROUPCATEGORY增加前处理" action="com.shjv.tdscdma.ebs.at.impl.group.GroupCategorySaveOrUpdateBeforeTreatment"/> 
      </ADD>
	  <MOD>
	  	<FILTER desc="GROUPCATEGORY修改前处理" action="com.shjv.tdscdma.ebs.at.impl.group.GroupCategorySaveOrUpdateBeforeTreatment"/>	
	  </MOD>
	  <OTHEROP/>
   </UDCOBJ>
3.2.3.9  数据保存后处理
基本说明：针对操作，做相应的连带处理；如增加了A对象时，需要修改B对象
文件：***_AT.xml （***为操作对象类型EBSType.***）
例如GROUPCATEGORY_AT.xml GroupCategoryAfterTreatment.java
<AfterTreatmentCfg>
	<Rmv>
	<ClassPath>com.shjv.tdscdma.ebs.at.impl.group.GroupCategoryAfterTreatment</ClassPath>
	</Rmv>
</AfterTreatmentCfg>
3.2.4 数据校验说明
3.2.4.10 校验文件配置
基本说明：对数据作：基本数据校验（数据长度、支持的字符等）、规格、license、名称重复等校验；分为增加、修改、删除场景。
文件：***.xml （***为操作对象类型EBSType.***）
例如：GROUPCATEGORY.xml GroupCategoryValidateUtils.java
<OpmValidation>
  <Add>
    <ClassPath>
com.shjv.tdscdma.ebs.validation.adapter.instance.group.GroupCategoryValidateUtils</ClassPath>
    <ClassPath>
	com.shjv.tdscdma.ebs.validation.adapter.instance.group.CheckGroupCategoryNumExpire</ClassPath>
	<ClassPath>
	com.shjv.tdscdma.ebs.validation.adapter.instance.group.GroupCategoryUniqueValidate</ClassPath>
  </Add>
  <Mod>
    <ClassPath> com.shjv.tdscdma.ebs.validation.adapter.instance.group.GroupCategoryValidateUtils</ClassPath>
    <ClassPath>
	com.shjv.tdscdma.ebs.validation.adapter.instance.group.GroupCategoryUniqueValidate</ClassPath>
  </Mod>
</OpmValidation>
3.2.4.11 错误码定义
基本说明：
校验时，如果不通过会有提示信息抛出到前端界面显示；后端需要定义相应的错误码和错误信息。
服务启动时，会将xml文件中的错误码读入内存errorlist，代码中抛出异常时，会在内存errorlist中，找到具体错误信息，构造一个opm异常

文件：java\udc_main\omc-common-buz\opm-common\src\main\conf\opm_errors_zh.xml
java\udc_main\omc-common-buz\opm-common\src\main\conf\opm_errors_en.xml
java\udc_main\omc-common-buz\opm-common\src\main\java\com\shjv\tdscdma\omc\common\opm\exception\OPMException.java
例如：
public final static int BACTHIMPORT_ADDDEV_FILE_EXCEPTION = 85554;
  <Error>
<code>85554</code>
<detail message="添加终端的 %s 行  %s 数据非法  "
 suggestion="请按照要求填写数据" />
  </Error>
  <Error>
    <code>85554</code>
    <detail message="Data in row %s and column %s on the Create Terminal sheet is invalid."  suggestion="Please fill in the data as required." />
  </Error>
3.2.4.12 界面显示信息和action中抛出的提示信息（i18n）
文件：
\java\udc_main\omc-web-ebsclient\src\main\conf\i18n_en_US.properties
\java\udc_main\omc-web-ebsclient\src\main\conf\i18n_en_CN.properties
Eclipse中编辑，中英文成对添加
例：
interface.web.user.substream=Substream
interface.web.user.substream=\u5B50\u7801\u6D41
3.3 配置数据导出（郭鹏）
3.3.1 前后台交互
1、omc-web-ebsclient\src\main\conf\udcsecurity\UdcSecurityMeta.xml
omc-web-ebsclient\src\main\conf\applicationContext-security.xml
新增对应URL权限如图:
 
 
	2、exportType 导出格式（1：csv；2：html，3：xml）
	   exportPageType 数据范围（1：本页数据；2：选中数据；3：全部数据）
3.3.2 后台数据处理
modelType 模式类型（不同模式可能导出数据不同）
 
title:根据模式类型设置，导出文件的每列的值；
type:填入modelType；
results:填入处理后的数据集合。
1、	文件头设置(title)：
用格式如下；
群组编号,群组名称,用户短号码,用户名,用户类型,用户群组优先级,部门（逗号为英文逗号）
2、	数据处理(results)：
根据exportPageType将所需数据查询出来；
遍历查询出的对象，将需要导出的数据以如图格式放入map中：
 
Map中key值需要唯一且不能乱改动，需参考3.3.3导出文件中的一致
将所有map组成集合放入result中。
3.3.3 导出文件配置：
如图根据exportType导出不同类型的文件，
文件统一放在\omc-web-ebsclient\src\main\webapp\WEB-INF\export目录下
 
1、	csv（请用Notepad++,UE等编辑器打开）
 
${title}即为3.3.2，java代码中设置的title
<#list results as crowUser>results即为3.3.2.1，java代码中设置的results；
crowdUser为重命名对象
${(crowdUser.GROUPNUMBER)!} crowdUser为重命名对象；GROUPNUMBER为3.3.2.2中map设置的参数一致即可。
2、	html
 
参考scv
3、	xml
 
参考scv
3.4 配置模板开发（郭鹏）
3.4.1 保存处理流程
 
				图3.4.1-1
3.4.1.13 IMSI保存
1、	如图3.4.1-1中的第一步：hsubTempSaveHandle将需要添加的字段set进udcHsub或者udcHsubcntxs中即可；
2、	如图3.4.1-1中第二步：统一方法入口为copyUDCUser2Template
if userType=0即为IMSI，进入方法copyUDCPsUser2Template将需要添加的字段set进UDCPsUserTemp或者UDCHsubcntxTemp中；
3、	如图3.4.1-1中第三步：prepareSaveTempParameterBean
if userType=0即为IMSI，将对象放置于parameterBeanList中入库。
3.4.1.14 终端用户保存
1、	如图3.4.1-1中的第一步：pttuserTempSaveHandle
将需要添加的字段set进udcPttuser，UDCWaterMark，UDCPttUserGisCfg中即可；
2、	如图3.4.1-1中第二步：统一方法入口为copyUDCUser2Template 
if userType=1即为终端用户，进入方法copyUDCPttUser2Template将需要添加的字段set进UDCPttUserTemp， UDCWaterMarkTemp，UDCPttUserGisCfgtemp中；
3、	如图3.4.1-1中第三步：prepareSaveTempParameterBean
if userType=1即为终端用户，将对象放置于parameterBeanList中入库。
3.4.1.15 固定用户保存
1、	如图3.4.1-1中的第一步：sipUserTempSaveHandle
将需要添加的字段set进UDCSipUser，UDCDCAttribute，UDCPttUserGisCfg中即可；
2、	如图3.4.1-1中第二步：统一方法入口为copyUDCUser2Templateif userType=2即为固定用户，进入方法copyUDCIpUser2Template，将需要添加的字段set进UDCIPUserTemp中，注意固定用户的类型；
3、	如图3.4.1-1中第三步：prepareSaveTempParameterBeanif userType=2即为固定用户，将对象放置于parameterBeanList中入库。
3.4.1.16 IMEI保存
1、	由于IMEI模板使用参数不多，暂时没有第一步；
2、	如图3.4.1-1中第二步：统一方法入口为copyUDCUser2Templateif userType=3即为IMEI，这里没有单独方法，可以直接只用udcImeisoftprivilagetemp对象；
3、	如图3.4.1-1中第三步：prepareSaveTempParameterBean
if userType=3即为IMEI，在这里对数据进行一些处理，将需要添加的字段set进udcImeisoftprivilagetemp中，再将对象放置于parameterBeanList中入库。
3.4.2 修改处理流程
修改流程与基本一致
固定用户的修改单独分开为：openUserIPUpdate
其他类型的模板为openUserUpdate
多了第一步，将模板对象还原为终端用户，IMSI,IMEI对象
 
3.4.2.17 IMSI修改
1、	还原对象；
2、	IMSI对象处理hsubTempUpdateHandle，将需要添加的字段set进udcPttuser，UDCWaterMark，UDCPttUserGisCfg中即可；
3、	统一方法入口为copyUDCUser2Template
if userType=0即为IMSI，进入方法copyUDCPsUser2Template将需要添加的字段set进UDCPsUserTemp或者UDCHsubcntxTemp中；
4、	统一方法入口为prepareUpdateTempParameterBean
if userType=0即为IMSI，将对象放置于parameterBeanList中入库。
3.4.2.18 终端用户修改
1、	还原对象；
2、	IMSI对象处理pttuserTempUpdateHandle，将需要添加的字段set进udcPttuser，UDCWaterMark，UDCPttUserGisCfg中即可；
3、	统一方法入口为copyUDCUser2Template
if userType=1即为终端用户，进入方法copyUDCPsUser2Template将需要添加的字段set进UDCPsUserTemp或者UDCHsubcntxTemp中；
4、	统一方法入口为prepareUpdateTempParameterBean
if userType=1即为终端用户，将对象放置于parameterBeanList中入库。
3.4.2.19 IMEI修改
1、	还原对象
2、	统一入口copyUDCUser2Template，if userType=3即为IMEI，这里没有单独方法，可以直接只用udcImeisoftprivilagetemp对象；
3、	prepareUpdateTempParameterBean，ifuserType=3即为IMEI，在这里对数据进行一些处理，将需要添加的字段set进udcImeisoftprivilagetemp中，再将对象放置于parameterBeanList中入库
3.4.2.20 终端用户修改
1、	使用openUserIPUpdate方法，
2、	使用终端用户的对象set，使用copyUDCIpUser2Template，在if userType=2即为固定用户，进入方法copyUDCIpUser2Template将需要添加的字段set进UDCIPUserTemp中，注意固定用户的类型；
3、	 直接入库即可

3.4.3 模板在开户中的使用
1、	终端用户：EbsUserManageAction.openUser()，根据用户类型如果是1则是终端用户
copyTemplate2UDCUser()方法中使用copyTemplate2UDCPttUser()还原默认终端用户的属性
(修改使用setTemp方法)
2、	固定用户：EbsUserManageAction.openUser()，根据用户类型如果是2则是固定用户
copyTemplate2UDCUser()方法中使用copyTemplate2UDCPsUser()还原默认终端用户的属性
(修改使用setTemp方法)
3、	IMSI：EbsImsiManagementAction.openIMSI(),copyTemplate2UDCPsUser()方法中还原IMSI的属性(修改使用setTemp方法)
4、	IMEI：EbsImeiManagementAction.openIMEI()，copyTemplate2IMEI方法中还原IMEI的属性
(修改使用setTemp方法)
3.5 批量导入开发（严朝祥）
3.5.1 相关功能配置
3.5.1.21 开发工具配置
主要是查看VB代码，引用宏（调用方法执行）；
以打开配置文件为例：
 

当前操作位打开隐藏的配置Sheet页，打开方法有三种：
1、直接双击showConfigSheet函数；
2、单机showConfigSheet函数，选择执行，就会发现sheet页栏会多出多个sheet页（就是我们的配置文件，只提供开发自身使用）；
3、配置快捷键，选择showConfigSheet函数，再选择选项，输入快捷键（如ctrl+j）,确定之后。关闭当前引用，直接在excel表格操作快捷键可以打开配置页。

3.5.1.22 ClientRule页配置
ClientRule页配置输入值的校验规则，用来检查输入的值是否合法。
配置规则：
 

1.	序列,相当于索引。
2.	网元版本，当前UDC使用的网元版本。
3.	页，指sheet页，如：页值为2，就等于添加卡sheet页
4.	列，指sheet页中的列（表格头部A，B，C..），如2页A列，就对应添加卡sheet页A列.
5.	中文正则表达式，指在中文模板中使用的校验规则，只能为正则表达式。
6.	English Regulation Format，指在英文模式下校验规则，只能为正则表达式。
7.	中文错误提示，指在中文模板中使用时的错误提示。
8.	English Error，指在英文模板中使用时的错误提示。
3.5.1.23 ServerRule 页配置
ServerRule页为多列联合校验，当某一列规则成立时，输入值是否允许为空，当前列是否唯一值，最大值等等。
配置规则说明：
 
	
1.	序列,相当于索引。
2.	版本，当前UDC使用的网元版本。
3.	模式，分为3GPP，BTRUNC ，3GPP+BTRUNC，模板切换到当前模式，当前规则才会生效，为空则默认为多种模式都兼容。
4.	检测值，分为两种，当前自身校验，如：MUSTFILL，获取当前页和列的值，判断当前页是否符合当前限定条件规则，如不符合则根据错误类型提示错误。（注：错误类型可以理解为中应为国际化取值）
检测值，检测区域联合校验，如：A列并且B列符合限定条件规则，当前输入值才输入正确。才能进行下一步的检测规则校验。
5.	限定条件，分中英文值，中文值在中文模板中引用，英文值在英文模板中引用。当前值即是校验规则，校验的对象就是检测值和检测区域。校验通过才能进行下一步的检测规则校验。
6.	检测规则，分为：EXIST,CEXIT,NOTEXIST,UNIQUE,PAIR,MAX,1VNMAX,MUSTFILL,CONDLEN,CONDREGU,SAME。
7.	错误类型，提示的错误类型，如：错误，警告。
3.5.1.24 ValidationConfig 配置
ValidationConfig为在切换模式或者模板初始化时，重新加载sheet页的规则，分为两种类型，一种为输入框提示，一种为下拉列表。
配置规则：
 
1.	sheet号，指sheet页，当前这一条规则为指定sheet页配置。
2.	语言，指当前这一规则适用于哪一种语言。
3.	网元版本，为系统配置的网元版本号。
4.	内容，规则配置，列+下拉值+提示信息，每一列的输入值以“|”分割，列+下拉值+提示信息以“#”分割，下拉值为多个时以“,”分割。
3.5.1.25 GroupColumns、USIMColumns、UserColumns配置
GroupColumns、USIMColumns、UserColumns配置群组，卡，用户初始化sheet页，当模板sheet做切换时，当前sheet页的标题字段会切换到当前模式字段，请看截图：
 
 
1.	切换模式之后，当前sheet页会转换到当前模式字段。
2.	当前标注的三个sheet页，每添加一个字段或者删除字段，都要在当前配置sheet页做相应的添加或者删除及修改。


3.5.1.26 Properties配置
Properties配置为参数配置项，相当于中英文国际化文件，提供给别的函数调用，及提示。
配置规则：
 

1.	第一列为key值，不能重复，函数中调用时，引用此key值
2.	第二列为中文值，在中文模式下提示。
3.	第三列为英文值，在英文模式下提示。

3.5.1.27 	数据校验
数据校验为用户导入某一块功能数据做导入前校验数据的合法性。操作及注释如下：
 

 
列：导入用户数据，在输入用户数据完成之后，点击检查。数据会自动检查输入数据是否合法，如不合法，问题会一一显示在数据校验sheet页当中。

3.5.1.28 	工具
当前sheet为如果用户导入数据量过大时，对于一些数字编号字段进行大批量生成，然后复制粘贴就可以，无需用户手动一个一个去输入。
 


3.5.1.29 	开发工具
开发工具是如需在某一个sheet定义规则函数时，在对应的sheet页类中添加函数方法。
 

3.5.1.30 	批量导入
入口：BatchOpenUserImpl.java(createUserInBatch())
 


3.6 常见问题和解答（邵珠成）
3.7 常见问题和解答（李战礼）
Q: SessionOperateUtil.java类中的getEBSDomainObjectByKey(Session session, Class<T> clazz, String key,V value)与listAll(Session session, Class<T> clazz)方法使用场景，何时使用，如果用到该对象的关联属性怎么操作？
A:只要能获得session都能使用此两种方法，返回值都是该对象的基本属性，故如果下面的业务逻辑只使用该对象的基本属性，则可以使用此方法提高执行效率。如果要用到关联对象属性，请使用上述方法再次查询关联对象基本属性即可。

4 MDC同步开发（赵宇）
4.1 增量同步开发（郭鹏）
4.1.1 新增字段同步
1、	新增接口对象的字段，文件目录一般都在\udc_main\omc-common-buz\opm-common\src\main\java\com\shjv\tdscdma\omc\common\opm\databean 
将新增的字段新增set进MDC接口对象中；
2、	新增字段导致对象同步逻辑变化
需要在\udc_main\omc-server-buz\omc-opm-server\src\main\conf \dispatch_ne.xml这个文件中查询自己修改的对象
 
如有逻辑变更请修改对象应操作(ADD,MOD,DEL)。
4.1.2 新增对象同步
1、	新增MDC接口对象，一般接口对象都在\udc_main\omc-common-buz\opm-common\src\main\java\com\shjv\tdscdma\omc\common\opm\databean目录下； 
2、	在\udc_main\omc-server-buz\omc-opm-server\src\main\conf\EAPP\V100R005 \NeBaseNeBeanControl.xml中新增配置项如下； 
3、	在\udc_main\omc-server-buz\omc-opm-server\src\main\conf\dispatch_ne.xml
中新增配置项如下：
⑴	如果没有同步逻辑可以使用如下配置 
⑵	如果需要有逻辑处理需要自己配置同步MDC的文件 
4、	如果新增对象需要在用户，群组中有后处理，需要在\udc_main\omc-server-buz\omc-opm-server\src\main\conf\dispatch_dev.xml  
这里逻辑和dispatch_ne.xml中一致。

4.2 全同步开发（赵宇）

4.2.1 全同步概述 
    UDC可以连接MDC设备，做全同步操作，也可以做数据导出。全同步状态下， UDC的开户数据会根据号段配置发送到MDC上。(包括用户，群组等数据，不包含卡和终端相关的数据)。MDC全同步/增量同步和MRS同步实现逻辑非常接近，接口，代码结构都在一起，唯一的差别就是传递的数据范围不一样。
 
4.2.2 全同步流程
    简易流程图如下: 其实和核心网全同步流程差异不大。唯一的区别就2个 :(1)	生成的数据文件不是加密的,是标准的mysqldump文件。(2)	信令交互核心网是用MML， UDC和MDC是用ZMQ消息。
  
一般定位问题或者数据代码，建议根据日志看代码流程:
 
这是一次成功的全同步交互日志，搜索 “now we have” 可以查询到所有发送的命令。这里看到有3个命令。对比成功和失败日志，可以知道问题原因。
 
三个命令分别的作用是:
(命令1) 告知MDC下载文件，提供下载地址，FTP用户名密码，文件路径等信息.
(命令2) 设置workkey，部分数据库table中的密码类字段会使用workkey来加密, MDC收到全同步文件后再对这些字段使用workkey来解密。(加密涉及MDC*XmlExporter*.java的prepareTempTables方法)
(命令3) 告知MDC可以让新的全同步数据生效，目前MDC收到此命令会做所有服务重启的操作。

以下是shaozhucheng整理的MDC/MRS全同步和增量同步的代码流程说明,可以参考。
  
4.3 常见问题和解答（赵宇）
4.3.1 	我第一次定位MDC全同步,增量同步的问题,只有这份文档和代码，能问的人很少，怎么办?
    找一个正常的环境，做类似同样的操作看下正常的日志是怎样的，然后比对错误的日志，找出错误日志的位置然后定位代码以确定问题。--这是在一个问题谁也没有遇到时，必须要看代码来定位的时候使用，刚解除MDC时要经常用，以熟悉代码结构。

4.3.2 什么样的MDC是正常，正常的MDC操作是怎样的？
正常的状态只有一种，而不正常的状态各有各的原因，也各有各的表现形式。
(1)	添加MDC设备
(2)	点击”全同步”，全同步成功后 MDC会重启，并且MDC服务器上的UDC也会被带动重启。--划重点，好好理解UDC什么时候才会重启，老师要考！
(3)	等到MDC重启好后，就会看到如下图的样子。
注意下图中红圈的部分，如果有其他的状态出现就说明设备处在不正常状态。
    
(4)	UDC上用户/组等数据的变更会同步下发给MDC,MDC的数据库中能看到对应的数据。
4.3.3 添加MDC/MRS设备添加不上怎么办?
添加不上就2个情况
1、	网络不通
注意4.0看 /java/med/med.log   5.0看 /java/med/server.log
对应时间点会出现连接异常。
（1） 常见的问题需要用 ping –I   UDC地址  网元地址 来确定点到点的连通性。
（2） Q3以前的版本，即便ping通了还是可能连接不上，要求UDC地址所在的网卡上的所有IP都要和MDC的地址相通，一般的解决办法是删除不正确的IP。--Q4没有这个问题。--具体还是建议看代码来确定。
2、	适配层不存在
看 /java/omp/server.log 查询关键字 “vveerr:”
UDC连接上网元后，先获取版本后，然后比较本地适配层和网元的版本号的一致性，找到一个一致的就判断成功。
下图比对日志，左边的版本为UDC支持的适配层版本号，右边的版本为网元的版本号。
注意：小版本号不一致也会匹配不上，必须版本号完全一样。 MDC和MRS共部署的环境返回的版本号是MDC的版本号，所以不能以MRS来添加。--划重点，老师要考！
  
4.3.4 MDC阻塞/不同步了怎么定位?
网元阻塞就2个情况
1、	有一个消息发送到MDC一直被MDC拒绝，所以UDC不断重试，除非可以重试成功，否则后面的所有命令都发不出去，设备管理页面上看，网元是阻塞状态。
注意4.0看 /java/bs/opmLog.log   5.0看 /java/bs/server.log .能看到明显不断重复发送命令并且不断报错的日志，并且可以从日志中判断出是什么命令引起的。
然后根据时间点，对照ubp_cm.log, cm日志中可以看到真实的失败原因。最最常见的就是UDC某一条数据没有删除就又新增了同样的数据, cm日志报主键冲突。
其他原因的问题还要根据日志具体分析。
2、	UDC每过2分钟会向MDC发送消息，查询MDC当前的同步号并且和UDC的同步号比较看是否一致，如果不一致就会禁止后续命令的下发。设备管理页面上看，一般的状态是“不同步”
注意4.0看 /java/bs/opmLog.log   5.0看 /java/bs/server.log
查询关键字” devSyno:”
  
devSyno:UDC增量同步号,当有消息发送给MDC并收到成功返回后+1
neSyno:MDC增量同步号,当MDC收到UDC发送过来的消息时+1
devUpdateid: UDC全同步号,全同步时随机生成并随全同步文件一起提供给MDC。
neUpdateid: MDC全同步号, 全同步时读取全同步文件来更新。
程序逻辑同步完成的判断标准为:
devSyno== neSyno  AND devUpdateid== neUpdateid
这个日志可以看到双方同步号的变化,找到第一次出现双方不一致的地方，然后确认UDC和MDC都在做什么就可以确定问题了。
4.3.5 升级和切换应用模式引起的MDC同步异常
   EAPP升级后都需要执行MDC全同步操作。
   EAPP切换应用模式后一定要手动执行MDC全同步操作，如果不执行，部分命令会引起阻塞，业务也会工作不正常。
   所以注意看操作日志，确保做了正确的操作！--划重点，老师要考！
4.3.6 任何时候都不要忘记看日志和代码来定位问题！




5 核心网同步开发（赵宇）
5.1 增量同步开发（邓雪磊）
5.1.1 增量同步涉及文件
NeCreateHsimMMLBeanServerImpl14U,
NeCreateHsimMMLBeanServerImpl2U, 
NeCreateUdchsubMMLBeanServerImpl14U,
NeCreateUdchsubMMLBeanServerImpl2U
UDC需要修改OMC代码库中的(OpMetaInfo_Opm_zh.xml, OpMetaInfo_Opm_en.xml)，这是制作核心网适配层的时候用到的配置文件。主要用于适配增量同步MML的参数。
安装完适配层后，这两个文件在服务器的位置：
/opt/UDC/common-conf/EME/eCNSV100R004C10SPC100/mediation/OpMetaInfo_Opm_zh(en).xml


5.1.2 增量同步流程
拿husim举例,  UDC会填充husim.java对象, 然后调用核心网适配层, 适配层会根据OpMetaInfo_Opm_zh(en).xml 中对于husim的具体属性, 生成MML语句.
UDC向核心网发送对应的MML语句.
MML语句可以通过搜索/opt/UBP/logs/udc_java/bs/opm.log 查看到
>>>>  more opmLog.log | grep HUSIM -a
最后opm进程生成的MML指令会通过med进程发送.
所以最终的发送情况需要观察/opt/UBP/logs/udc_java/med/med.log
注：
适配层中的xml文件由UDC负责， 目前看就2个文件， 需要提交OMC的SVN。
适配层中的xxx.py由核心网负责。



5.2 全同步开发（邓雪磊）
5.2.1 全同步涉及文件
SyncDateUpdateExecutor.java, 
CreateSyncTempTable30.java,  
CreateSyncTempTableBase.java
核心网那边需要修改 (适配层中的xxx.py脚本)
 
UDC会建立出一些table, 例如husim新增临时表hss_husim_view_temp,然后将视图HSS_HUSIM_VIEW中的数据复制到表中, 最后在全同步结束后删除临时表.
(视图的作用是多维护一个设备ID, 用户UDC向多种设备做全同步)
(临时表的作用是将CRUD和接口数据传输解耦,比如两边对同一数据的加解密算法不一致)
5.2.2 生成全同步文件
UDC调用核心网适配层中的py脚本.
 
每个py脚本都会生成一个对应的csv文件.
比如husim.py,这个脚本里面本质是读取临时表hss_husim_view_temp,生成tbl_husim.csv文件
 
生成的csv文件会统一放到UDC的ftp中.
使用sftp连接  UDCIP,  2122端口,  用户名密码opm/ Hwftp@com
可以找到这些csv文件.
这些csv文件的格式完全是由核心网的xxx.py决定, 由核心网适配层保证和核心网的格式匹配.
(因为不同版本的核心网对数据的格式要求是不一样的,所以就需要不同版本的适配层)

全同步的文件在服务器上的位置：
/home/ubp/udc/ftpd/opm/syncdata/ESCN/192_168_1_49/hss_dattbl/hssdata.xml
最后一步核心网会连接到UDC的FTP,下载这些FTP文件, 然后告知UDC全同步成功.
(很多时候csv文件可以生成, 但是全同步会失败,就是因为最后一步出了问题, 如果UDC日志看不出问题,需要联系核心网接口人帮忙看一下)
5.3 核心网增量同步和全同步命令实例
注意:核心网响应报文是RETCODE到END 所有内容，并且包括这两个词哦。
5.3.1 增量同步实例
1、	连接步骤1：测试连通性--不涉及命令,不涉及接口
PING -I 源地址  目的地址
connect, from 172.17.173.207 to 172.17.173.123


2、	连接步骤2 ：登录核心网
2017-05-10 14:19:32,474 pool-1-thread-79 INFO [CGPMMLReportProcessor] 112 frame is +++    cgp/*meid:0 mename:站点管理*/        2017-05-10 14:19:32+08:00
o&m    #15
%%/*10365 meid=0*/lgi :op="admin", pwd=****** 
retcode = 0  操作成功

---    end

3、	连接步骤3 : 获取核心网版本号(目前14U要求 核心网和UDC的中英文字符集要一致,要么都中文要么都英文，因为返回报文有差别) -- UDC解析返回报文,获取版本号
2017-05-10 14:19:32,875 pool-1-thread-80 INFO [CGPMMLReportProcessor] 112 frame is +++    CGP/*MEID:0 MENAME:站点管理*/        2017-05-10 14:19:32+08:00
O&M    #17
%%/*10367 MEID=0*/LST ME:MEID=5;%%
RETCODE = 0  操作成功

操作结果如下
------------
        域标识  =  1
      子网标识  =  0
        网元ID  =  5
      网元名称  =  ecns210
      网元类型  =  eCNS网元
      网元版本  =  V100R004C10SPC200
网元制造商名称  =  NULL
网元自定义状态  =  正常
  网元本地名称  =  NULL
  网元锁定状态  =  解锁
    网元国家码  =  NULL
    网元接口ID  =  eCNSV100R004C10SPC200
      网元语言  =  中文
  网元补丁版本  =  V100R004C10SPC200
(结果个数 = 1)

---    END

4、	常规命令1  心跳-握手  目前UDC是60秒一次 (心跳命令报错会触发UDC重新登录核心网)
2017-05-10 14:19:52,491 pool-1-thread-85 INFO [CGPMMLReportProcessor] 112 frame is +++    CGP/*MEID:0 MENAME:站点管理*/        2017-05-10 14:19:52+08:00
O&M    #18
%%/*10369 MEID=0*/SHK HAND:;%%
RETCODE = 0  Operation succeeded.

5、	常规命令2  查询版本号 (UDC一般每40秒会查询一次同步号,用户控制UDC的数据同步逻辑，核心网只需要将当前同步号返回。 同步号增加的逻辑是：核心网每收到一次UDC的命令，如果执行成功并返回给UDC就+1， 如果网络错误没有将成功响应返回给UDC的情况不考虑)
2017-05-10 14:20:04,305 pool-1-thread-86 INFO [CGPMMLReportProcessor] 112 frame is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 14:20:04+08:00
O&M    #20
%%/*10372 MEID=5*/LST HSSSYNCNO:;%%
RETCODE = 0  操作成功

操作结果如下：
--------------
    同步号  =  137
全同步标识  =  bbb8500c-751f-4ef7-a59d-fe4cb52bcf5c
(结果个数 = 1)

---    END

全同步步骤1: 通知核心网下载文件
2017-05-10 11:17:11,103 pool-1-thread-8 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 11:17:11+08:00
o&m    #28920
%%/*20006 meid=5*/dld dattbl:ftpsrvip=******  usr="opm", pwd=******  filepath="syncdata/eme/172_17_173_123";%%
retcode = 0  操作成功

下载数据表文件
--------------
会话号  =  1
(结果个数 = 1)

---    end
5.3.2 全同步实例

1、	全同步步骤1
1.1	其实UDC不会再发送命令了，但是核心网至少要保证每5秒至少回吐一次导入进入


2017-05-10 11:17:11,104 pool-1-thread-8 INFO [CommonMMLReportParser] 49 parse mml report: msgbody is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 11:17:11+08:00
o&m    #28920
%%/*20006 meid=5*/dld dattbl:ftpsrvip=******  usr="opm", pwd=******  filepath="syncdata/eme/172_17_173_123";%%
retcode = 0  操作成功

下载数据表文件
--------------
  会话号  =  1
上报类型  =  下载
    状态  =  进行中
    进度  =  0%
(结果个数 = 1)

---    end
1.2	全同步步骤1.2 下载命令回吐， 注意1.1到1.4 这些命令都是UDC发送1个命令后，核心网并不断开连接在响应报文中每过一段时间回吐一些数据，但是不关闭连接，一直到下载成功为止。 如果20秒以上UDC收不到核心网的返回则会主动断开连接并中断全同步操作。
2017-05-10 11:17:13,105 pool-1-thread-9 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 11:17:13+08:00
o&m    #28920
%%/*20006 meid=5*/dld dattbl:ftpsrvip=******  usr="opm", pwd=******  filepath="syncdata/eme/172_17_173_123";%%
retcode = 0  操作成功

下载数据表文件
--------------
  会话号  =  1
上报类型  =  下载
    状态  =  进行中
    进度  =  99%
(结果个数 = 1)

---    end
1.3	全同步步骤
2017-05-10 11:17:13,111 pool-1-thread-9 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 11:17:13+08:00
o&m    #28920
%%/*20006 meid=5*/dld dattbl:ftpsrvip=******  usr="opm", pwd=******  filepath="syncdata/eme/172_17_173_123";%%
retcode = 0  操作成功

下载数据表文件
--------------
  会话号  =  1
上报类型  =  下载
    状态  =  进行中
    进度  =  100%
(结果个数 = 1)

---    end
1.4	全同步步骤1.4
2017-05-10 11:17:13,116 pool-1-thread-9 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 11:17:13+08:00
o&m    #28920
%%/*20006 meid=5*/dld dattbl:ftpsrvip=******  usr="opm", pwd=******  filepath="syncdata/eme/172_17_173_123";%%
retcode = 0  操作成功

下载数据表文件
--------------
  会话号  =  1
上报类型  =  下载
    状态  =  成功
    进度  =  100%
(结果个数 = 1)

共有5个报告
---    end
2、	全同步步骤2:设置WORKKEY(仅用于全同步文件部分密码字段加密)
2017-05-10 11:17:14,594 pool-1-thread-11 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 11:17:14+08:00
o&m    #28921
%%/*20007 meid=5*/set workkey:******
retcode = 0  操作成功

设置结果
--------
 网元id  模块号  框号    槽号    主/备状态  设定结果描述

 5       1       0       0       主用       操作成功    
 5       4       0       1       主用       操作成功    
(结果个数 = 2)

---    end
3、	全同步步骤3: IMP DATTBL估计是通知核心网导入数据?真实命令如下
2017-05-10 11:17:22,802 pool-1-thread-10 INFO [CGPMMLReportProcessor] 112 frame is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 11:17:22+08:00
O&M    #28922
%%/*20008 MEID=5*/IMP DATTBL:;%%
RETCODE = 0  操作成功

---    END

4、	全同步步骤4: FMT 这个命令也带百分比回写。具体是什么意思待沟通。。。
2017-05-10 11:17:23,003 pool-1-thread-12 INFO [CGPMMLReportProcessor] 112 frame is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 11:17:22+08:00
O&M    #28923
%%/*20009 MEID=5*/FMT :;%%
RETCODE = 0  操作成功

FMT进度报告
-----------
      表的总个数  =  2828
已经完成的表个数  =  0
      完成百分比  =  0%
(结果个数 = 1)

---    END

2017-05-10 11:17:28,009 pool-1-thread-13 INFO [CommonMMLReportParser] 49 parse mml report: msgBody is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 11:17:27+08:00
O&M    #28923
%%/*20009 MEID=5*/FMT :;%%
RETCODE = 0  操作成功

FMT进度报告
-----------
      表的总个数  =  2828
已经完成的表个数  =  703
      完成百分比  =  24%
(结果个数 = 1)

---    END

2017-05-10 11:17:32,910 pool-1-thread-14 INFO [CommonMMLReportParser] 49 parse mml report: msgBody is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 11:17:32+08:00
O&M    #28923
%%/*20009 MEID=5*/FMT :;%%
RETCODE = 0  操作成功

FMT进度报告
-----------
      表的总个数  =  2828
已经完成的表个数  =  879
      完成百分比  =  31%
(结果个数 = 1)

---    END

2017-05-10 11:17:37,915 pool-1-thread-15 INFO [CommonMMLReportParser] 49 parse mml report: msgBody is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 11:17:37+08:00
O&M    #28923
%%/*20009 MEID=5*/FMT :;%%
RETCODE = 0  操作成功

FMT进度报告
-----------
      表的总个数  =  2828
已经完成的表个数  =  2228
      完成百分比  =  78%
(结果个数 = 1)

---    END

2017-05-10 11:17:41,319 pool-1-thread-17 INFO [CommonMMLReportParser] 49 parse mml report: msgBody is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 11:17:41+08:00
O&M    #28923
%%/*20009 MEID=5*/FMT :;%%
RETCODE = 0  操作成功

FMT进度报告
-----------
      表的总个数  =  2828
已经完成的表个数  =  2828
      完成百分比  =  100%
(结果个数 = 1)

---    END

5、	全同步步骤4.N : 步骤4核心网回吐的最后消息
2017-05-10 11:17:41,325 pool-1-thread-17 INFO [CommonMMLReportParser] 49 parse mml report: msgBody is +++    eCNS/*MEID:5 MENAME:ecns210*/        2017-05-10 11:17:41+08:00
O&M    #28923
%%/*20009 MEID=5*/FMT :;%%
RETCODE = 0  操作成功

共有6个报告
---    END

6、	全同步步骤5 : 通知核心网重启以生效，14U核心网收到这个消息会重启，目的是数据生效。（3U如果都是MML估计这个命令可以不发或者不处理）
2017-05-10 11:17:42,526 pool-1-thread-18 INFO [CGPMMLReportProcessor] 112 frame is +++    cgp/*meid:0 mename:站点管理*/        2017-05-10 11:17:42+08:00
o&m    #28924
%%/*20010 meid=0*/rst me:meid=5;%%
retcode = 0  操作成功

操作结果如下
------------
 机架号  位置号  槽号    位置    业务模块号  模块描述  操作结果

 0       0       0       前插板  1           omp       操作成功
 0       0       1       前插板  2           lcp       操作成功
 0       0       1       前插板  3           uip       ****** 
 0       0       1       前插板  4           hsp       操作成功
 0       0       1       前插板  5           grp       操作成功
 0       0       1       前插板  6           spp       操作成功
 0       0       1       前插板  7           spp       操作成功
 0       0       1       前插板  8           spp       操作成功
 0       0       1       前插板  9           spp       操作成功
 0       0       1       前插板  10          spp       操作成功
 0       0       1       前插板  11          spp       操作成功
 0       0       1       前插板  12          spp       操作成功
 0       0       1       前插板  13          spp       操作成功
 0       0       1       前插板  14          spp       操作成功
 0       0       1       前插板  15          spp       操作成功
 0       0       1       前插板  16          spp       操作成功
 0       0       1       前插板  17          spp       操作成功
 0       0       1       前插板  18          sgp       操作成功
 0       0       1       前插板  19          sgp       操作成功
 0       0       1       前插板  20          sgp       操作成功
 0       0       1       前插板  21          sgp       操作成功
 0       0       1       前插板  22          sgp       操作成功
 0       0       1       前插板  23          sgp       操作成功
 0       0       1       前插板  24          sgp       操作成功
 0       0       1       前插板  25          sgp       操作成功
 0       0       1       前插板  26          sgp       操作成功
 0       0       1       前插板  27          sgp       操作成功
 0       0       1       前插板  28          sgp       操作成功
 0       0       1       前插板  29          sgp       操作成功
 0       0       1       前插板  30          upp       操作成功
 0       0       1       前插板  31          gwp       操作成功
 0       0       1       前插板  32          amp       操作成功
 0       0       1       前插板  33          tup       操作成功
 0       0       1       前插板  34          tup       操作成功
 0       0       1       前插板  35          tup       操作成功
 0       0       1       前插板  36          tup       操作成功
 0       0       1       前插板  37          tup       操作成功
 0       0       1       前插板  38          tup       操作成功
 0       0       1       前插板  39          tup       操作成功
 0       0       1       前插板  40          tup       操作成功
 0       0       1       前插板  41          tup       操作成功
 0       0       1       前插板  42          tup       操作成功
 0       0       1       前插板  43          tup       操作成功
 0       0       1       前插板  44          tup       操作成功
 0       0       1       前插板  45          tsp       操作成功
 0       0       1       前插板  46          tgp       操作成功
 0       0       1       前插板  47          tdp       操作成功
 0       0       1       前插板  48          bpp       操作成功
 0       0       1       前插板  49          prp       操作成功
(结果个数 = 49)

---    end

(PYTHON)特别说明：UDC全同步前会生成全同步文件，调用的以下PYTHON
		String command = String.format("python %s %s %s %s %s %s %s %s %s",
				pythonFilePath, host, dbUser, pwd, dbName, syncNo, updateId,
				devId, dstDir);
pythonFilePath -- 是PY脚本的位置, UDC负责控制，确保文件存在
host -- UDC告知核心网连接的数据库的IP地址
dbUser -- 数据库账号
pwd --数据库密码
dbName --数据库名(一般都传ebs)
syncNo -- 增量同步号，一般UDC传递0, 意思是核心网全同步完成后将增量同步号设置成传入的值(0).
updateId -- 全同步号，全同步完成后，核心网需要将全同步号更新成此值。
devId -- 14U设备可能UDC会连接2个以上，而且要考虑多个核心网设备共存的情况。 部分表里面可能存放着给多个核心网的数据， 部分表需要通过devId(设备ID)做过滤.(在适配层中的SQL中需要加入此过滤条件)
dstDir -- UDC负责控制输出的文件夹目录，一般是./EME/111_111_111_111 带有设备完整版本号设备类型IP地址的文件夹。目前看如果文件夹不存在由py负责建立，有问题可再沟通。
--------------特别说明：其实以前我们少设计了数据库port的参数，后来3306改3307引起不好问题，这次也加上吧。 

(HUSIM,HSUB,HUSBCNTX)添加卡命令举例, 需要发 ADD HUSIM, ADD HSUB, mod hsubcntx(修改上下文)  三个命令。 以前14U可能不同版本还要求不一样， 
3U这边需要特别注意下卡的添加和修改接口(比如要求怎么发指令，目前不同版本的3U是不是发送指令的顺序或者数量有差异？ 之前14U在UDC侧针对不同版本的命令发送顺序做过特殊处理)
2017-05-10 16:49:03,104 pool-1-thread-77 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 16:49:03+08:00
o&m    #467
%%/*11564 meid=5*/add husim:******  kivalue=******  lockstatus=unblock, addkitype=single, optype=global, authalg=milenage;%%
retcode = 0  操作成功

设置结果
--------
 网元id  模块号  框号    槽号    主/备状态  设定结果描述

 5       1       0       0       主用       操作成功    
 5       4       0       1       主用       操作成功    
(结果个数 = 2)

---    end

2017-05-10 16:49:03,577 pool-1-thread-79 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 16:49:03+08:00
o&m    #468
%%/*11565 meid=5*/add hsub:imsi=******  isdn="3771", ueambrmaxul=102400000, ueambrmaxdl=102400000, lockstatus=unlock;%%
retcode = 0  操作成功

设置结果
--------
 网元id  模块号  框号    槽号    主/备状态  设定结果描述

 5       1       0       0       主用       操作成功    
 5       4       0       1       主用       操作成功    
(结果个数 = 2)

---    end

2017-05-10 16:49:04,024 pool-1-thread-82 INFO [CGPMMLReportProcessor] 112 frame is +++    ecns/*meid:5 mename:ecns210*/        2017-05-10 16:49:04+08:00
o&m    #469
%%/*11566 meid=5*/mod hsubcntx:selectby=imsi******  imsi=******  prov=addpdncntx, cntxid=1, defaultapnflag=yes, ueaddind=dynamic, apnni="elte", pdngwalloctype=dynamic, qosclasuid=9, prilevel=1, preemptioncap=disable, preemptionvul=enable, ambrmaxreqbwul=102400000, ambrmaxreqbwdl=102400000;%%
retcode = 0  操作成功

设置结果
--------
 网元id  模块号  框号    槽号    主/备状态  设定结果描述

 5       1       0       0       主用       操作成功    
 5       4       0       1       主用       操作成功    
(结果个数 = 2)

---    end

其他数据相关的增量命令这里不罗列了,和卡的增量命令格式差不多。

5.4 常见问题和解答（赵宇）
5.4.1 我第一次开发核心网的功能，有什么办法:找以前前面的同事做过的功能，找到提交记录，然后合入测试并在过程中读懂每一个文件的作用。
OMC的文件修改参考 ywx200448的提交记录. 这两个文件修改很简单,需要细心.
http://10.148.136.124/svn/eOMC910/trunk/TTR4.0/omc-adapter-layer
 
UDC的文件修改可参考WX215645在做OPC功能的提交纪录
http://10.160.144.127/svn/WN_eUBP_CODE_VOB/TTR40/branches/BRANCH_eAPPV100R004C10SPC100B180/java/udc_main
 

5.4.2  关于核心网设备是否正常，添加核心网添加不上，核心网阻塞/不同步的问题定位。
     请参照4.3章节MDC的常见问题和解答 。 这些都是通用的设备处理逻辑。
5.4.3  核心网特别问题1:中英文匹配引起的全同步/连接失败
     历史稳定版本最容易出现的问题， 因为核心网中英文返回的报文会不一样，所以14U要求中英文UDC和核心网要一致,不然会引起全同步等各种操作异常问题,因为一个中国的UDC保不齐什么时候就不认识核心网发回来的英文字符了^ ^. 不过2U没有这个问题，因为有一个字符集对齐的接口。
5.4.4  核心网特别问题2：2U核心网无论怎样都不能全同步成功。
     排除规格等问题，最常见的是: UDC地址不在2U核心网LST  FTPSCLTDPORT列表中，这个FTP列表需要到核心网上查询, 上限是20个，如果满了，新连接的UDC就不能上报这个FTP信息了，这样核心网就找不到UDC的FTP端口了。 因为核心网默认向外连接的FTP端口是22，其他端口都需要上报，我的天。。
5.4.5  核心网特别问题3:  UDC无法创建和核心网的连接，总是被拒绝。
核心网最大连接数配置，LMT也占用，最多6个。
LST USRMAXONLINE
SET USRMAXONLINE就是配置，最多6个
这个值可以往小设置，但是不能超过6. UDC这边偶有发生，因为僧多粥少呗。出了问题找到个别人的UDC把核心网设备删除了，自己就能用了^ ^. 有时候LMT被别人占用自己登陆不上，就强制做核心网全同步，核心网就重启了，这样你就可以登录LMT了。 什么LMT是什么？ 就是IE/PC客户端登录核心网操作的意思。
5.4.6  核心网POOL关系的含义
   UDC做一个POOL关系，其实就为了1个目的： 2个同版本核心网选择1个ZONE，这样1个卡信息就可以同时发送给这2个核心网了。
场景说明：核心网有主备关系，目前的实现逻辑是 UDC连接上2个互为主备的核心网，就好像连接了2个独立的核心网一样，UDC并不感知哪个核心网是主，这并不重要。 UDC只负责把相同的卡等数据同步给这2个设备即可。 
POOL关系限制： 1. 设备一对一 2.版本号要一致  3. 有POOL关系的核心网设备ZONE要设置一样  4.不是POOL关系的核心网一定是不同ZONE。  5. 1个ZONE允许配置1个(MDC或MRS)+1个核心网(2U或14U)。
5.4.7 最终的解决办法：还是那句，老老实实看代码,看日志来定位问题。

6 UDC同步开发（蔡茂）
分布式组网下，需要将主控UDC的数据通过实时增量或全量同步的方式下发给节点UDC，因此变更对象或参数时，需要处理UDC间的数据同步。
6.1 增量同步开发（蔡茂）
    UDC间增量同步可以称为实时增量数据同步，在主控UDC上配置数据时，在数据写入主控的数据库后，同时拷贝一份该数据通过Http消息发送给节点UDC，节点UDC同步入库。这样保证了UDC间的数据实时一致性。
6.1.1 相关XML配置
6.1.1.1 dispatch_ne.xml配置
dispatch_ne.xml主要配置网元下发的数据规则，包括核心网、MDC、MRS、节点UDC等。此处主要是配置节点UDC的数据下发规则。以user为例：
<UDCOBJ obj="USER">
      <ADD>
         <FILTER desc="用户MDC分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.user.DispatchUserForMDC"/>
		 <FILTER desc="用户MRS分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.user.DispatchUserForMRS"/>
		 <FILTER desc="Fleet共享分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.user.DispatchUserForFleet"/>
      </ADD>
	  <MOD>
		 <FILTER desc="用户修改分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.user.DispatchUser"/>
		 <FILTER desc="Fleet共享分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.user.DispatchUserForFleet"/>
	  </MOD>
	  <DEL>
		 <FILTER desc="用户删除分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.user.DispatchUser"/>
		 <FILTER desc="Fleet共享分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.user.DispatchUserForFleet"/>
	  </DEL>  
	  <OTHEROP/>
</UDCOBJ>

1、	如果是新增对象，需要ADD，MOD，DEL标签中视情况分别增加一条配置数据（如果该对象不涉及ADD，MOD，DEL中任一项操作也可以不配置到对应标签中），desc建议统一命名为“Fleet共享分发”，action为数据筛选处理类，在6.1.2章节中会详细介绍。
2、	该配置文件是对变更对象时的下级网元数据分发策略的处理，如果是变更参数不需要处理该配置文件。
3、	如果新增对象不涉及数据筛选处理，即该对象所有数据都下发节点UDC，则可以使用通用配置。如下例：
   <UDCOBJ obj="CALLINHIBITED">
      <ADD>
          <FILTER desc="呼入呼出UDC分发"    action="com.shjv.tdscdma.ebs.server.dispatcher.instance.zone.DispatchZoneForUDC"/>
      </ADD>
      <MOD>
          <FILTER desc="呼入呼出UDC修改分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.zone.DispatchZoneForUDC"/>
      </MOD>
      <DEL>
          <FILTER desc="呼入呼出UDC删除分发" action="com.shjv.tdscdma.ebs.server.dispatcher.instance.zone.DispatchZoneForUDC"/>
      </DEL>
      <OTHEROP/>
   </UDCOBJ>
6.1.1.2 udc_sync.xml配置
udc_sync.xml为2017年10月udc间同步效率优化引入的xml配置文件，旨在减少udc间同步的开发代码量，实现代码开发配置化的思路。该配置文件增量同步和全同步都会使用。以group对象为例：
  <udcobj name="com.shjv.tdscdma.ebs.bean.udc.UDCGroup" type="GROUP" clear="true" iopsSync="true" version="4.0.1">
     <dependecy class="com.shjv.tdscdma.ebs.sync.udc.data.UDCSyncGroupDependency" />
     <export class="" mode="fleet"/>
  </udcobj>
1、	参数变更不需要配置该文件。
2、	新增对象如果需要UDC间同步则必须配置该文件，配置详解如下：
1）	udcobj.name为新增类的class名字，必须携带包名（com.shjv.tdscdma.ebs.bean.udc）。
2）	type 是在代码中添加的ebsType的枚举。
3）	clear 为true 则标记节点UDC在全同步时会先清除对象，默认配置为true，只有那些没有ADD命令的对象才置为flase，例如全局参数（UDCGlobalSwitch），只可以设置，不能添加。
4）	iopsSync为iops类型专用，如果设置为true标识该对象同步给IOPS，否则不同步，默认为true。
5）	version主要是版本兼容使用，4.0新增对象时目前版本号是4.0.2，5.0新增对象是5.0.2，该版本号会随着外发版本而变更，新增对象时请根据最新的版本号填写。
6）	dependency标签页，配置的是主从UDC增量同步时，需要处理的依赖关系类，详细可参考6.1.3章节。
7）	export标签页中class是特殊处理的导出类，可参考6.2.2章节，mode为fleet表示主控导出数据按照fleet号段导出（在fleetobj中数据），mode为all表示所有数据导出。导出数据后给节点UDC全同步使用。
6.1.2 数据筛选处理
     分布式组网下，节点UDC一般是按照fleet号段（isdn或imsi号段）获取数据的，分布式组网设计时，引入了fleetobj对象来存储要同步给节点UDC数据，对应数据表是opm_fleetobj。每个对象在增删的同时，都会根据fleet号段（或其他业务逻辑）来判断是否需要在fleetobj中增删改对象。我们称这个过程为数据筛选过程。当每个对象变更后，会通过查询fleetobj来判断是否要发送给节点UDC。一般情况下，如果fleetobj存在，则需要发送，否则不需要发送。
      在增加新对象时，需要添加一个com.shjv.tdscdma.ebs.server.dispatcher.instance.对象名.对象名forfleet的一个类。
        
类新增后，需要实现getDispatchList方法，该方法需要完成两个事情：
1）	根据数据筛选原则，写入fleetobj：
一般情况下，固网按照fleet isdn（或imsi）号段来决定是否写入fleetobj。车或rapid或iops等全部写入fleetobj。
 
特殊情况下，主要是用户和群组，以及和用户群组直接相关的对象，如组群、用户层级关系等。如果新增对象和用户或群组存在直接关系，需要特别注意：
① 用户的筛选原则是用户短号在fleet isdn号段内或所加入的群组在fleet isdn号段。
② 群组的筛选原则是群组号在fleet isdn号段内或群组内存在有fleet isdn号段内的用户。
以上两种情况，即使用户或群组本身不在fleet isdn号段内，也有可能需要同步到节点UDC（写fleetobj），这两种情况在DispatchGroupUserForFleet中处理：
 
其中，mcpttclientid与用户有直接关系，当用户需要同步到节点UDC时，mcpttclientid也需要同步，所以直接在用户的判断条件里，增加了mcpttclientid的处理。

2）	根据数据筛选原则，构造发送给节点UDC的消息，返回mmlbeanlist
在写fleetobj的同时（满足写fleetobj的条件），需要构造发给节点UDC的消息，该消息会通过http发给节点UDC，节点UDC会根据该消息解析对象入库。   
构造消息的方法如上图代码所示：需要找到当前fleet下的所有zone，每个zone对应一个节点UDC，对应一份消息的拷贝，把新老对象设置到ConstructMMLBean中即可。
6.1.3 对象依赖处理
所有新增对象，如果需要udc间同步，都需要一个对象关系依赖处理的类：
      
Dependency的类处理当前只有增量同步需要，全同步已经不需要了。Dependency主要是解决如下问题：
1）	自增ID：对象由主控UDC同步到节点UDC时，在节点UDC上会重新生成，因此自增ID是不能同步的，所以主控在发给节点之前，需要把自增ID置空。
 
2）	去除循环依赖关系： 主控对象通过hibernate导出数据时，会把依赖关系一起导出，如果存在循环依赖，例如UDCUser和UDCSipUser（两者互相依赖），这样会导致转化为jason格式出现死循环，导致堆栈溢出。所以为了避免这种情况，在主控上导出数据时，把循环依赖关系切断。
 
3）	重新构建循环依赖关系： 节点UDC入库之前需要把切断的循环依赖关系重新构建起来。
 
4）	处理修改操作：如果是MOD操作，节点UDC入库时需要将旧的对象查出来，把新值赋值给旧对象，然后使用旧对象入库。
 

注意：如果不是新增对象，仅是参数变更，则只需要处理这一步即可。
6.2 全同步开发（蔡茂）
6.2.1 相关XML配置
UDC间全同步也需要配置udc_sync.xml文件，基本配置可参考6.1.1.2章节。对于只需要基本配置的对象，这一步可以省略。这里主要讲一下全同步的特殊配置：
 
1）	对于有关联对象的新增对象，需要处理relateobj配置项。当前UDC全同步机制已经修改为主控直接导出DB，节点UDC直接导入DB来同步数据。所以当主控导出数据时必须把所有关联对象的表也导出，而节点UDC导入DB时，也需要先导入关联对象的表。
<relateobjlist>配置项中的关联对象，按照依赖顺序配置，最上面是没有其他对象依赖它。
节点UDC在清除数据时，会按照从上到下的顺序清除，导入数据时会按照从下往上顺序导入。
<relateobj>配置项中，class是关联对象的类名，parent为其所依赖的父对象，relateKey为本关联对象用于关联父对象的key（DB中的字段，通过该字段可以找到父对象）。
2）	对于需要处理跨版本兼容的对象，需要实现*SyncAdapter类，暂时该特性未交付，待交付后再补充详细说明。


6.2.2 数据导出特殊处理
一般情况下，主控UDC的导出方式只需要配置udc_sync.xml即可：
 
特殊情况下，如果全导出和按照fleet导出无法满足导出需求时，则需要自己实现导出类：
 
代码实现如下例（找到该fleet相关的所有userlocation）：
 
6.3 常见问题和解答（蔡茂）
6.3.1 UDC间同步需要修改那些文件？
   Q：新增一个对象或参数需要涉及那些文件修改
   A：如果新增对象，需要修改dispatch_ne.xml,新增dispatch对象名forfleet类，udc_sync.xml,UdcSync对象名Dependency类。
      如果新增参数，则仅需要修改UdcSync对象名Dependency类。
6.3.2 如何判断数据筛选的原则？
   Q：如何决定新增一个对象该如何筛选数据给节点UDC。
   A：新增对象如果存在ISDN号段或者间接与ISDN号段有关（通过用户、群组等关联）则按照fleet isdn号段来筛选数据，如果与imsi 号有关或者间接有关则按照fleet imsi号段筛选数据。
      如果与isdn号段、imsi号段都不存在关系，则一般不用筛选数据，直接把所有数据同步到节点UDC，如部门等。








7 第三方接口开发（邵珠成）

7.1 NBI接口开发（尹良运）
7.1.1 NBI接口简介
1.	NBI接口（北讯定向BOSS接口），底层使用的是Soap协议进行通信，SOAP 是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息。
2.	编写NBI接口所涉及的代码在udc-websvc-nbi工程中。
 
图7-1 NBI工程目录

3.	NBI接口在项目中的调用过程
 
图7-2 EBS基本流程
4.	NBI接口简图说明
 
图7-3 NBI接口模型图



7.1.2 新增接口编写思路
1.	查看接口开发文档，了解新接口的功能
2.	根据开发文档中数据类型相关信息，在com.td.udc.nbi.soap.dto包下新建对应的实体类
3.	实体类创建成功后，在com.td.udc.nbi.soap包下新建对应的接口（接口中定义所需的抽象方法）以及接口的实现类
4.	接口和实现类编写完成后，在com.td.udc.nbi.soap包下的CommonSoapService.java类中继承新增的接口
5.	在application.xml中commonSoapService的bean标签中，添加属性，属性值为新增接口。
6.	使用SoapUI测试工具进行功能测试。
7.1.3 新增接口代码示例 
PS：代码较多，截取重要部分展示
1.	新增配置对象类
基本说明：新增一项配置，涉及增删改查的操作对象，需要参数生成get、set方法、序列化serialVersionUID、生成toString方法
例如：VPNRange.java

package com.td.udc.nbi.soap.dto;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

/**
 * @author zWX10417
 *
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class VPNInfo{
     // 注解表示该属性是必须的，使用SoapUI工具测试时会体现作用
	@XmlElement(required=true)   
	private Long vpnCode;
	@XmlElement(required=true)
	private String vpnName;
	private String contract;
	
	public void setVpnCode(Long vpnCode) {
		this.vpnCode = vpnCode;
	}
	public Long getVpnCode() {
		return vpnCode;
	}
	public void setVpnName(String vpnName) {
		this.vpnName = vpnName;
	}
	public String getVpnName() {
		return vpnName;
	}
	public void setContract(String contract) {
		this.contract = contract;
	}
	public String getContract() {
		return contract;
	}
	public void setPhoneNumber(String phoneNumber) {
		this.phoneNumber = phoneNumber;
	}
	
	@Override
	public String toString() {
		return "VPNInfo [vpnCode=" + vpnCode + ", vpnName=" + vpnName + ", contract=" + contract + ", phoneNumber="
				+ phoneNumber + ", label=" + label + ", maxGroups=" + maxGroups + ", maxTerminalUsers="
				+ maxTerminalUsers + ", maxFixedCameras=" + maxFixedCameras + ", maxDispatchers=" + maxDispatchers
				+ ", maxIMSIs=" + maxIMSIs + "]";
	}
	
}


2.	新增接口
基本说明：接口中的抽象方法按照接口开发文档中的规定编写
例如：VpnManage.java

package com.td.udc.nbi.soap;

import java.util.List;

import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;

@WebService(name = "VpnManager", targetNamespace = WsConstants.NS)
public interface VpnManager {
	@WebMethod
	@WebResult(name = "resultCode")
	@XmlElement(required = true)
	int addVpn(
			@WebParam(name = "vpnInfo") @XmlElement(required = true) VPNInfo vpnInfo);

	@WebMethod
	@WebResult(name = "resultCode")
	@XmlElement(required = true)
	int updateVpn(
			@WebParam(name = "vpnInfo") @XmlElement(required = true) VPNInfo vpnInfo);

	@WebMethod
	@WebResult(name = "resultCode")
	@XmlElement(required = true)
	int deleteVpn(
			@WebParam(name = "vpnCode") @XmlElement(required = true) long vpnCode);

	@WebMethod
	@WebResult(name = "resultCode")
	@XmlElement(required = true)
	int getVpn(
			@WebParam(name = "queryConditions") QueryConditions conditions,
			@WebParam(mode = WebParam.Mode.OUT, name = "queryPagedResult") Holder<QueryPagedResult> queryPagedResult,
			@WebParam(mode = WebParam.Mode.OUT, name = "vpnInfo") Holder<List<VPNInfo>> vpnInfos);
}

3.	新增接口实现类
基本说明：实现新增接口的抽象方法
例如：VpnManageImpl.java

package com.td.udc.nbi.soap;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.ws.Holder;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;

public class VpnManagerImpl extends NBIManagerBase implements VpnManager {
	/ / 序列化
    private static final long serialVersionUID = -3956696847955395993L;
	private static Logger logger = Logger.getLogger(VpnManagerImpl.class);
	private UDCVpn udcVpn = null;
	
	@Override
	public int addVpn(VPNInfo vpnInfo) {   / / 添加VPN
        / / 刷新session有效时长，每调用一次就刷新一次
		keepSession();    

		if (vpnInfo == null) {
			logger.warn("invalid param when addVpn:vpnInfo is null");
			return WsResultCode.ERROR_INVALID_PARAM;
		}

        / / 基础数据校验
        returnCode = validateAddVpn(vpnInfo);  

        if (returnCode != null) {
            return returnCode.intValue();
        }

        udcVpn = new UDCVpn();

        / / 将外部传入的对象转换成和hibernate映射的对象
        returnCode = constructAddVpn(udcVpn, vpnInfo);
        
        / / 操作数据库（将转换后的对象存入数据库中）
        returnCode = sendOneCommand(EBSType.VPN, OperationEnum.ADD, udcVpn);

        if (returnCode != null) {
            return returnCode.intValue();
        }

        return WsResultCode.SUCCESS;
    }

    @Override
    public int updateVpn(VPNInfo vpnInfo) {  / / 更新VPN
	
    }

	@Override
	public int deleteVpn(long vpnCode) {   / / 删除VPN
		
	}

	@Override
	public int getVpn(QueryConditions conditions,
			Holder<QueryPagedResult> queryPagedResult,
		Holder<List<VPNInfo>> vpnInfos) {     / / 查询VPN
	
		
		keepSession();

        / / 创建查询条件
		returnCode = constructQueryPager(conditions);
		
        / / 创建查询数据库的规则（条件）
		Rule rule = constructQueryRuler(conditions, soapServiceType.service_vpn);
    / / 根据规则查询数据库中所有信息
	List<EBSDomainObject>ObjectList=getServerForClientItf().getRecordByRule(UDCVpn.class, getEnhancedRule(toEnhancedRule(rule)));
		
        / / 查询数据库中中记录数
		int totalCount =(int) getServerForClientItf().getTotalCount(UDCVpn.class, getEnhancedRule(toEnhancedRule(rule)));
		
        / / 构建分页查询的结果
		returnCode = constructQueryPageResult(queryPagedResult,ObjectList,totalCount);
		
		if(returnCode != null){
			 return returnCode.intValue();
		}
		
        / / 将数据库中的对象转换为外部传入的对象
		UDCVpn vpnTemp = null;
		vpnInfos.value = new ArrayList<VPNInfo>();
		for(EBSDomainObject ebsObj:ObjectList){
			vpnTemp =  (UDCVpn)ebsObj;
			VPNInfo vpnInfo = new VPNInfo();
			returnCode = transUDCVpntoVpnInfo(vpnInfo, vpnTemp);
			logger.error("szc transUDCVpntoVpnInfo:"+returnCode);
			if(returnCode != null){
				 return returnCode.intValue();
			}
			vpnInfos.value.add(vpnInfo);
		}
	
		return WsResultCode.SUCCESS;
	}

    / / 将数据库中的对象转换为外部传入的对象
	private Integer transUDCVpntoVpnInfo(VPNInfo vpnInfo, UDCVpn udcVpn){	
		return null;
	}
	
    / / 将外部传入的对象转换成和hibernate映射的对象  
	private Integer constructAddVpn(UDCVpn vpn,VPNInfo vpnInfo){
		vpn.setVpnCode(vpnInfo.getVpnCode());
		vpn.setVpnName(vpnInfo.getVpnName());
		vpn.setContact(vpnInfo.getContract());
		vpn.setContact_phone_number(vpnInfo.getPhoneNumber());
		vpn.setLabel(vpnInfo.getLabel());
		vpn.setMaxDispatchers(vpnInfo.getMaxDispatchers());
		vpn.setMaxFixedCameras(vpnInfo.getMaxFixedCameras());
		vpn.setMaxGroups(vpnInfo.getMaxGroups());
		vpn.setMaxIMSIs(vpnInfo.getMaxIMSIs());
		vpn.setMaxTerminalUsers(vpnInfo.getMaxTerminalUsers());
		return null;
	}
	private Integer constructUpdateVpn(UDCVpn vpn,VPNInfo vpnInfo){
		return null;
	}

	/ / 数据校验
	private Integer validateAddVpn(VPNInfo vpnInfo){}
	private Integer validateUpdateVpn(VPNInfo vpnInfo){}
	private Integer checkVpnCode(Long vpnCode){}
	private Integer checkVpnName(String vpnName){}
	private Integer checkVpnContact(String vpnContact) {}
    private Integer checkVpnPhoneNumber(String contact_phone_number){}
    private Integer checkVpnLabel(String label){}
    
}

4.	修改CommonSoapService.java以及实现类
基本说明：
package com.td.udc.nbi.soap;
import javax.jws.WebService;

/**
 * JAX-WS2.0的WebService接口定义类 * 使用JAX-WS2.0 annotation设置WSDL中的定义.
 * 使用WSResult及其子类包裹返回结果. 使用DTO传输对象隔绝系统内部领域对象的修改对外系统的影响.
 * 
 */
// name  指明wsdl中<wsdl:portType>元素的名称
@WebService(name = "CommonSoapService", targetNamespace = WsConstants.NS)
public interface CommonSoapService extends SystemManager,VpnManager,VpnAdminManager,VpnRangeManager,UserManager,ImsiManager{


}

package com.td.udc.nbi.soap;

import java.util.List;

import javax.annotation.Resource;
import javax.jws.WebService;
import javax.xml.ws.Holder;
import javax.xml.ws.WebServiceContext;

import org.apache.log4j.Logger;

import com.td.udc.nbi.soap.dto.ImsiInfo;
import com.td.udc.nbi.soap.dto.NBIManagerBase;
import com.td.udc.nbi.soap.dto.QueryConditions;
import com.td.udc.nbi.soap.dto.QueryPagedResult;
import com.td.udc.nbi.soap.dto.UserInfo;
import com.td.udc.nbi.soap.dto.VPNAdmin;
import com.td.udc.nbi.soap.dto.VPNInfo;
import com.td.udc.nbi.soap.dto.VPNRange;

/**
 * WebService服务端实现类.
 */
//  serviceName指明WSDL中<wsdl:service>与<wsdl:binding>元素的名称
//  endpointInterface属性指向Interface类全称.
@WebService(serviceName = "CommonSoapService", targetNamespace = WsConstants.NS)
public class CommonSoapServiceImpl implements CommonSoapService,ServiceContext {
	@Resource
	private WebServiceContext context;
	private SystemManager systemManager;
	private VpnManager vpnManager;
	private VpnAdminManager vpnAdminManager;
	private VpnRangeManager vpnRangeManager;
	private UserManager userManager;
	private ImsiManager imsiManager;
	protected static Logger log = Logger.getLogger(CommonSoapServiceImpl.class);
	
	@Override
	public WebServiceContext getServiceContext() {
		return context;
	}
	public SystemManager getSystemManager() {
		return systemManager;
	}
	public void setSystemManager(SystemManager systemManager) {
		this.systemManager = systemManager;
	}
	public VpnManager getVpnManager() {
		return vpnManager;
	}
	public void setVpnManager(VpnManager vpnManager) {
		this.vpnManager = vpnManager;
	}
	
    / / 登录
	@Override
	public int login(String userName, String password) {
		if(context!=null){
			
			log.error("szc dfsafsaf:"+context.getMessageContext());
		}else{
			log.error("szc dfsafsa null");
		}
		
		try{
			return getSystemManager().login(userName, password);
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}
	}

    / / 登出
	@Override
	public int logout() {
		try{
			return getSystemManager().logout();
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}	
	}

    / / 获取版本号
	@Override
	public int getVersion(Holder<String> version) {
		try{
			return getSystemManager().getVersion(version);
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}	
	}
	
	@Override
	public int keepAlive() {
		try{
			return getSystemManager().keepAlive();
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}	
	}
	
    
	@Override
	public int addVpn(VPNInfo vpnInfo) {
		try{
			return getVpnManager().addVpn(vpnInfo);
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}
	}

	@Override
	public int updateVpn(VPNInfo vpnInfo) {
		try{
			return getVpnManager().updateVpn(vpnInfo);
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}
	}

	@Override
	public int deleteVpn(long vpnCode) {
		try{
			return getVpnManager().deleteVpn(vpnCode);
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}
	}

	@Override
	public int getVpn(QueryConditions conditions,
//			Holder<QueryPagedResult> queryPagedResult, Holder<VPNInfoList> vpnInfos) {
		Holder<QueryPagedResult> queryPagedResult, Holder<List<VPNInfo>> vpnInfos) {
		try{
			return getVpnManager().getVpn(conditions, queryPagedResult, vpnInfos);
		}catch(Exception e){
			log.error("szc exception:"+e);
			return WsResultCode.ERROR_SERVICE_EXCEPTION;
		}
	}

}

5.	修改applicationContext.xml
基本说明：/udc-websvc-nbi/src/main/webapp/WEB-INF/classes/applicationContext.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	">
	<!-- 拦截器 -->    
    <bean id="authInterceptor" class="com.td.udc.nbi.soap.interceptor.AuthInterceptor"/>  

	<!-- 定义CXF服务对应的BEAN -->
	<jaxws:endpoint implementor="#commonSoapService"
		address="/CommonSoapService">
		<!--<jaxws:features>
			<bean class="org.apache.cxf.feature.LoggingFeature" />
		</jaxws:features>-->
		 <jaxws:inInterceptors>    
            <ref bean="authInterceptor"/>    
        </jaxws:inInterceptors> 
	</jaxws:endpoint>

	<bean id="commonSoapService" class="com.td.udc.nbi.soap.CommonSoapServiceImpl">
		<property name="systemManager">
			<bean class="com.td.udc.nbi.soap.SystemManagerImpl" >
				<property name="context" ref="commonSoapService"/>
			</bean>
		</property>

		<property name="vpnManager">
			<bean class="com.td.udc.nbi.soap.VpnManagerImpl" >
			<property name="context" ref="commonSoapService"/>
			</bean>
		</property>
		<property name="vpnAdminManager">
			<bean class="com.td.udc.nbi.soap.VpnAdminManagerImpl" >
			<property name="context" ref="commonSoapService"/>
			</bean>
		</property>
		<property name="vpnRangeManager">
			<bean class="com.td.udc.nbi.soap.VpnRangeManagerImpl" >
			<property name="context" ref="commonSoapService"/>
			</bean>
		</property>
		<property name="userManager">
			<bean class="com.td.udc.nbi.soap.UserManagerImpl" >
			<property name="context" ref="commonSoapService"/>
			</bean>
		</property>
		<property name="imsiManager">
			<bean class="com.td.udc.nbi.soap.ImsiManagerImpl" >
			<property name="context" ref="commonSoapService"/>
			</bean>
		</property>
	</bean>	 
</beans>

7.1.4 新增接口测试方法
PS：测试工具选用SoapUI
1.	右键单击File，在弹出的菜单中选择“New Workspace”创建一个工作空间
 
 
 
 

2.	右键单击TTR4.0，在弹出的菜单中选择“New SOAP Project”或按组合键：Ctrl-N（Windows 系统）/ cmd-N（mac系统），创建Soap工程
 

3.	页面弹出“New SOAP Project”，输入Project Name：udcnbi-soap，输入Initial WSDL：http://www.webservicex.net/WeatherForecast.asmx?wsdl，并点击“OK”。（添加WSDK，每一个项目都基于一个对应的WSDL，导入WSDL之后就可以获取到WSDL包含的所用信息，方便了测试用例的编写）
 
 
 
验证接口是否正常，把Initial WSDL输入到浏览器地址栏中，可得到xml
 
4.	测试Soap接口login功能：点击login左测得加号，出想下级菜单Request 1后并双击，弹出Request 1页面，将页面中的？替换为相应的数据，点击左上角的绿色三角形提交按钮
 

 
 
5.	测试Soap接口addVpnRange
 

 
 
6.	其它Soap接口方法类似

7.2 UDI接口开发（赵宇）
7.2.1 DC创建动态组入口
UdcGroupApi.java
====动态组UDC会保存opm_group,opm_group_user, 
opm_dynamic_group_members（此表存在的目的是记录动态组包含的静态组列表）
都会同步给MDC
--createDynamicGroup 动态组创建
  --modDynamicGroup 动态组修改
  --delDynamicGroup 动态组删除
=====派接组和临时组UDC只负责分配和存储组号，表opm_temporary_group
此表UDC自己维护，不需要同步给MDC。组员信息都是MDC控制和UDC无关。
  --createGroupid 临时组/派接组分配组号
  --delGroupid 临时组/派接组删除组号
  --checkGroupid 临时组合派接组的组号检查: 每24小时，SDK会发起组号核查, 如果有不一致的地方，取DC和UDC的交集组号列表，大家各自更新统一。比如DC离线后等等情况，可能会有删除组号消息发送不到UDC的情况，需要核查来恢复。 
7.2.2 终端UE创建动态组入口
 
   终端动态组和DC动态组的处理逻辑主要差异：
1.	Group表中记录的DCID不一样。一个存终端ISDN，一个存调度员ISDN.
2.	终端动态组规格50，不能包含静态组，因为很多终端使用，要求在几秒内建立完成。
3.	非OWNER的终端用户可以选择退出终端创建的动态组， 但是不能退出DC创建的动态组。
4.	终端不存在派接组，临时组这样的接口。只有动态组的创建，修改，删除和退出。
5.	终端不能指定组号，只能由UDC分配。DC两个方式都可以。
7.2.3 动态组,临时组,派接组 组号分配逻辑
1. DC号段和临时组号没有关系。
  2. DC先找到DC所在的ZONE。
  3. 通过ZONE获取所有的ISDN号段。
  4. ISDN号段从大到小排列分配号码， 跳过已存在的号码，网关号段，出局规则。
  5. 如果是4.0Q4/5.0X4以后， 如果从节点车上创建临时组，派接组， 要需要保证号码落在FLEET号段内。(动态组不受此影响)
  6. 5.0的X4版本，又要求组号落在VPN号段范围内。也就是用VPN号段对上面的号码范围再做交集。
 其实分配组号的方法都是serverForClientItf.allocGroupForDcUser
7.2.4 如何增加一个UDI接口
配置一个类UdcGroupApi, 并配置一个xml定义到urlrewrite.xml
因为structs的默认规则,方位udc_group_api自动会访问到UdcGroupApi.
而这个urlrewrite.xml意思是所有访问…/v1.0/group/checkgroupid的http请求转到/api/udc_group_api下面。
后面的方法名createDynamicGroup
 


7.3 Rest API 接口开发（邵珠成）
7.3.1 Rest API服务介绍
本服务为udc与第三方系统的restful接口服务，提供数据配置和查询功能，目前已实现udc与网关（egw）之间的接口。后续新增对端网元时，可在原有框架的基础上增加相应的管理员账号和接口。
7.3.2 Rest API在ebs架构中的位置
 
7.3.3 Rest api服务相关的数据流 
 
1）	单udc场景时，Rest API接收对端网元（eGW）的请求；然后调用opm服务进行入库和数据分发；然后调用对端网元（eGW）的接口，实现数据变更通知功能。
2）	混合组网场景时，从车上的Rest API接收对端网元（eGW）的请求；需要将数据转发到从的UDI服务；UDI服务接收到请求后，将数据转发到主UDC的UDI服务；主UDI服务调用主的OPM服务进行入库和数据分发；然后主从分别调用对端网元（eGW）的接口，实现数据变更通知功能。
3）	混合组网场景时，主车上的Rest API接收对端网元（eGW）的请求；实现于单udc场景类似，只是从上收到增量同步消息后，会通知接入从UDC的对端网元数据变更。


7.3.4 鉴权认证流程 
 

1）	初次请求（挑战认证），对端网元携带管理员用户名 username，Rest API 返回 realm 和 nonce（随机数）值
2）	鉴权认证请求，对端网元携带username 、realm、 nonce和生成的加密值 response值。 Response生成算法如下：response=SHA256(SHA256(pwd+realm )+nonce) ，“ +” 为字符串连接
3）	认证成功返回 sessionId
4）	后续业务请求携带 sessionId 和 username，即可完成鉴权认证。

   
7.3.5 代码位置
 

7.3.6 如何新增一个接口？
7.3.6.1 如果新增对端网元，需要新增加一种管理员类型。
Eroot管理员登录之后可以进行管理员的配置。需要继承相应的管理员的增删改查。

7.3.6.2 新增restful 接口
a.	udc-rest-api\src\main\java\com\td\udc\restApi\controller目录新增处理controller类，继承RestApiManagerBase。
b.	填写正确的@RequestMapping 中的uri；填写正确的RequestMethod
c.	参考之前的代码结构，实现摘要认证方法调用，数据校验，数据转化，执行命令，数据转化等处理过程

7.3.6.3 从rest API转发数据到从UDI
新增接口，无需新增代码

7.3.6.4 从UDI转发数据到主UDI保存数据
依赖于UDC间主从同步对象的配置（对象解析和依赖去除），新增接口，无需新增代码

7.3.6.5 新增数据变更通知
a．	udc_main\omc-server-buz\omc-opm-server\src\main\java\com\shjv\tdscdma\ebs\https\notify 中新增处理类，获取通知需要发送到的对端网元的IP和端口列表。
b．	此处理类必须实现NotifyItf接口中的getTarget方法。
c．	udc_main\omc-server-buz\omc-opm-server\src\main\conf\HttpNotify\ ebs_http_notify.xml中配置此类。
d．	配置文件的配置方法，如下图：
 


